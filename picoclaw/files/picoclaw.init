#!/bin/sh /etc/rc.common
#
# Copyright (C) 2021-2026  LIKE2000-ART
#
# This file is part of picoclaw .
# 
# This is free software, licensed under the MIT License.
#


START=99
USE_PROCD=1
NAME=picoclaw
PROG=/usr/bin/picoclaw
CONFDIR=/etc/picoclaw
CONF=$CONFDIR/config.json
WORKSPACE=$CONFDIR/workspace

get_tz()
{
	SET_TZ=""

	[ -e "/etc/localtime" ] && return

	for tzfile in /etc/TZ /var/etc/TZ
	do
		[ -e "$tzfile" ] || continue
		tz="$(cat $tzfile 2>/dev/null)"
	done

	[ -z "$tz" ] && return

	SET_TZ=$tz
}

init_config(){
	local ws="$1"
	[ -d $CONFDIR ] || mkdir -p $CONFDIR 2>/dev/null
	[ -d "$ws" ] || mkdir -p "$ws" 2>/dev/null
	
	if [ ! -s $CONF ]; then
		cp /usr/share/picoclaw/picoclaw-config.json $CONF
	fi

	# Create symlinks for hardcoded ~/.picoclaw paths in upstream Go code
	# OpenWrt root home is typically /root (or / on older systems)
	for hdir in /root /; do
		if [ -d "$hdir" ] && [ "$hdir" != "$CONFDIR" ]; then
			if [ ! -L "$hdir/.picoclaw" ]; then
				rm -rf "$hdir/.picoclaw" 2>/dev/null
				ln -s "$CONFDIR" "$hdir/.picoclaw" 2>/dev/null
			fi
		fi
	done

	# If workspace is empty/missing templates, run onboard to generate them
	if [ ! -f "$ws/AGENTS.md" ]; then
		mv $CONF ${CONF}.bak 2>/dev/null
		${PROG} onboard >/dev/null 2>&1 || true
		mv ${CONF}.bak $CONF 2>/dev/null
	fi
}

start_instance() {
	local cfg="$1"
	config_get_bool enabled $cfg enabled 1
	config_get delay $cfg delay 0
	[ "x$enabled" = "x1" ] || return 1

	# Read all UCI settings early and export them as environment variables
	# so both onboard initialization and the background daemon share them.
	config_get_bool logger $cfg logger 1
	config_get gateway_host 'gateway' 'host' '0.0.0.0'
	config_get gateway_port 'gateway' 'port' '18790'
	
	config_get workspace 'agent' 'workspace' "$WORKSPACE"
	config_get restrict_workspace 'agent' 'restrict_to_workspace' '0'
	
	config_get_bool heartbeat_enabled 'heartbeat' 'enabled' 1
	config_get heartbeat_interval 'heartbeat' 'interval' '30'

	export PICOCLAW_HOME="$CONFDIR"
	export PICOCLAW_GATEWAY_HOST="$gateway_host"
	export PICOCLAW_GATEWAY_PORT="$gateway_port"
	export PICOCLAW_AGENTS_DEFAULTS_WORKSPACE="$workspace"
	export PICOCLAW_AGENTS_DEFAULTS_RESTRICT_TO_WORKSPACE="$restrict_workspace"
	export PICOCLAW_HEARTBEAT_ENABLED="$heartbeat_enabled"
	export PICOCLAW_HEARTBEAT_INTERVAL="$heartbeat_interval"

	init_config "$workspace"

	[ $(awk -F. '{print $1}' /proc/uptime) -lt "120" ] && sleep $delay

	procd_open_instance
	get_tz

	# Pass the exported variables to the daemon process
	procd_set_param env PICOCLAW_HOME="$PICOCLAW_HOME"
	[ -z "$SET_TZ" ] || procd_append_param env TZ="$SET_TZ"
	procd_append_param env PICOCLAW_GATEWAY_HOST="$PICOCLAW_GATEWAY_HOST"
	procd_append_param env PICOCLAW_GATEWAY_PORT="$PICOCLAW_GATEWAY_PORT"
	procd_append_param env PICOCLAW_AGENTS_DEFAULTS_WORKSPACE="$PICOCLAW_AGENTS_DEFAULTS_WORKSPACE"
	procd_append_param env PICOCLAW_AGENTS_DEFAULTS_RESTRICT_TO_WORKSPACE="$PICOCLAW_AGENTS_DEFAULTS_RESTRICT_TO_WORKSPACE"
	procd_append_param env PICOCLAW_HEARTBEAT_ENABLED="$PICOCLAW_HEARTBEAT_ENABLED"
	procd_append_param env PICOCLAW_HEARTBEAT_INTERVAL="$PICOCLAW_HEARTBEAT_INTERVAL"

	# Run picoclaw gateway mode (daemon with channels support)
	procd_set_param command /bin/sh -c "
		${PROG} gateway >> /var/log/picoclaw.log 2>&1 &
		PICOCLAW_PID=\$!
		{
			while true; do
				LOG_SIZE=\$(ls -l /var/log/picoclaw.log | awk '{print int(\$5/1024)}')
				if [ \$LOG_SIZE -gt 100 ]; then
					tail -n 100 /var/log/picoclaw.log > /var/log/picoclaw.log.tmp
					mv /var/log/picoclaw.log.tmp /var/log/picoclaw.log
				fi
				sleep 3600
			done
		} &
		LOG_MANAGEMENT_PID=\$!
		trap \"kill -TERM \$PICOCLAW_PID; kill -TERM \$LOG_MANAGEMENT_PID; exit\" SIGINT SIGTERM EXIT
		wait \$PICOCLAW_PID
	"
	[ "x$logger" = "x1" ] && procd_set_param stderr 1
	procd_set_param respawn
	procd_close_instance
}

start_service() {
	config_load 'picoclaw'
	config_foreach start_instance 'basic'
}

service_triggers() {
      procd_add_reload_trigger "picoclaw"
}
